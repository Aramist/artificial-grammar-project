# == Define Model == #

# This is a model with a multiple linear RNNs stack on top of each other
# with nonlinear multi-layer perceptrons connecting them.

# Inspired by: https://arxiv.org/abs/2303.06349

from pathlib import Path

import jax
import orbax.checkpoint as ocp
import utils
from flax import nnx
from flax.nnx import Linear, Sequential, gelu
from flax.nnx.nn.recurrent import RNN, SimpleCell


class ResidualLayer(nnx.Module):
    def __init__(self, dimension: int, *, residual=True, rngs: nnx.Rngs):
        self.linear1 = Linear(dimension, dimension, rngs=rngs)
        self.bn = nnx.BatchNorm(dimension, rngs=rngs)
        self.residual = residual

    def __call__(self, x: jax.Array):
        return gelu(self.bn(self.linear1(x))) + x


class LRUBlock(nnx.Module):
    def __init__(self, dim_in, dim_out, num_layers, *, rngs: nnx.Rngs):
        self.linear_in = Linear(dim_in, dim_out, rngs=rngs)
        self.cell = SimpleCell(
            in_features=dim_in,
            hidden_features=dim_out,
            rngs=rngs,
            activation_fn=(lambda x: x),
        )
        self.rnn = RNN(self.cell, rngs=rngs)
        self.mlp_layers = [ResidualLayer(dim_out, rngs=rngs) for _ in range(num_layers)]
        self.mlp = Sequential(*self.mlp_layers)

    def __call__(self, x):
        return self.mlp(self.rnn(x))


class LRUModel(nnx.Module):
    @classmethod
    def from_metadata(cls, metadata: dict, rngs: nnx.Rngs):
        """Create a model from metadata.

        Args:
            metadata (dict): Metadata containing model parameters.
            rngs (nnx.Rngs): Random number generator state.

        Returns:
            LRUModel: An instance of the LRUModel class.
        """
        return cls(
            dim_in=metadata["dim_in"],
            dim_hidden=metadata["dim_hidden"],
            dim_out=metadata["dim_out"],
            mlp_depth=metadata["mlp_depth"],
            num_layers=metadata["num_layers"],
            rngs=rngs,
        )

    def __init__(
        self,
        dim_in: int,
        dim_hidden: int,
        dim_out: int,
        mlp_depth: int,
        num_layers: int,
        *,
        rngs: nnx.Rngs,
    ):
        self.dim_in = dim_in
        self.dim_hidden = dim_hidden
        self.dim_out = dim_out
        self.mlp_depth = mlp_depth
        self.num_layers = num_layers
        self.rngs = rngs

        # Save all initialization info in one place to make it easier to save and load
        self.metadata = {
            "dim_in": dim_in,
            "dim_hidden": dim_hidden,
            "dim_out": dim_out,
            "mlp_depth": mlp_depth,
            "num_layers": num_layers,
        }

        self.lru_blocks = [
            LRUBlock(dim_in=dim_in, dim_out=dim_hidden, num_layers=mlp_depth, rngs=rngs)
        ] + (num_layers - 1) * [
            LRUBlock(
                dim_in=dim_hidden, dim_out=dim_hidden, num_layers=mlp_depth, rngs=rngs
            )
        ]
        self.lrus = Sequential(*self.lru_blocks)
        self.readout_layer = Linear(dim_hidden, dim_out, rngs=rngs)

    def __call__(self, x: jax.Array) -> jax.Array:
        """Evaluate the model on the input data.
        The input data is a batch of sequences of indices in the range [0, vocab_size).

        Args:
            x (jax.Array): The input data. The shape is (batch_size, seq_len). Dtype is int32.

        Returns:
            jax.Array: The output of the model. The shape is (batch_size, seq_len, vocab_size).
        """
        return self.readout_layer(self.lrus(nnx.one_hot(x, 6)))

    def save(self, save_dir: Path) -> None:
        """Save the model to a file.

        Args:
            path (str): The path to save the model.

        Raises:
            ValueError: If the save directory already exists.
        """

        # orbax only accepts absolute paths
        save_dir = save_dir.absolute()
        if save_dir.exists():
            # Raise an error if the directory already exists
            raise ValueError(f"Directory {save_dir} already exists.")

        recurrent_meta = self.metadata
        # Rng states cannot be saved. These will need to be regenerated upon loading the model
        _, _, recurrent_state = nnx.split(self, nnx.RngState, ...)
        recurrent_ckptr = ocp.Checkpointer(ocp.CompositeCheckpointHandler())
        recurrent_ckptr.save(
            save_dir,
            args=ocp.args.Composite(
                state=ocp.args.StandardSave(recurrent_state),
                metadata=ocp.args.JsonSave(recurrent_meta),
            ),
        )

    @classmethod
    def load_from_save(cls, save_dir: Path, rngs: nnx.Rngs) -> "LRUModel":
        """Load the model from a saved checkpoint.

        Args:
            save_dir (Path): Save directory generated by LRUModel.save()
            rngs (nnx.Rngs): RNG state

        Returns:
            LRUModel: The loaded model.
        """
        return utils.load_model(save_dir.absolute(), cls)
